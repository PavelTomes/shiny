% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/render-cached-plot.R
\name{renderCachedPlot}
\alias{renderCachedPlot}
\title{Plot output with cached images}
\usage{
renderCachedPlot(expr, cacheKeyExpr, cacheResetEventExpr = NULL,
  baseWidth = 400, aspectRatioRate = 1.2, growthRate = 1.2, res = 72,
  scope = "app", env = parent.frame(), quoted = FALSE,
  outputArgs = list())
}
\arguments{
\item{expr}{An expression that generates a plot.}

\item{cacheKeyExpr}{An expression that returns a cache key. This key should
be a unique identifier for a plot: the assumption is that if the cache key
is the same, then the plot will be the same.}

\item{cacheResetEventExpr}{An expression or block of code that accesses any
reactives whose invalidation should cause the cached plots to be cleared.
If \code{NULL} (the default) the cache will not get cleared.}

\item{baseWidth}{A base value for the width of the cached plot.}

\item{aspectRatioRate}{A multiplier for different possible aspect ratios. For
example, with a value of 1.2, the possible aspect ratios for plots will be
1:1, 1:1.2, 1:1.44, and so on, getting wider, as well as 1.2:1, 1.44:1, and
so on, getting taller.}

\item{growthRate}{A multiplier for different cached image sizes. For example,
with a \code{width} of 400 and a \code{growthRate} of 1.25, there will be
possible cached images of widths 256, 320, 400, 500, 625, and so on, both
smaller and larger.}

\item{res}{The resolution of the PNG, in pixels per inch.}

\item{scope}{The scope of the cache. This can be \code{"app"} (the default),
\code{"session"}, or the path to a directory to store cached plots. See the
Cache Scoping section for more information.}

\item{env}{The environment in which to evaluate \code{expr}.}

\item{quoted}{Is \code{expr} a quoted expression (with \code{quote()})? This
is useful if you want to save an expression in a variable.}

\item{outputArgs}{A list of arguments to be passed through to the implicit
call to \code{\link{plotOutput}} when \code{renderPlot} is used in an
interactive R Markdown document.}
}
\description{
Renders a reactive plot, with plot images cached to disk.
}
\details{
\code{expr} is an expression that generates a plot, similar to that in
\code{renderPlot}. Unlike with \code{renderPlot}, this expression does not
take reactive dependencies. It is re-executed only when the cache key
changes.

\code{cacheKeyExpr} is an expression which, when evaluated, returns an object
which will be serialized and hashed using the \code{\link[digest]{digest}}
function to generate a string that will be used as a cache key. This key is
used to identify the contents of the plot: if the cache key is the same as a
previous time, it assumes that the plot is the same and can be retrieved from
the cache.

This \code{cacheKeyExpr} is reactive, and so it will be re-evaluated when any
upstream reactives are invalidated. This will also trigger re-execution of
the plotting expression, \code{expr}.

The key should consist of "normal" R objects, like vectors and lists. Lists
should in turn contain other normal R objects. If the key contains
environments, external pointers, or reference objects -- or even if it has
such objects attached as attributes -- then it is possible that it will
change unpredictably even when you do not expect it to. Additionally, because
the entire key is serialized and hashed, if it contains a very large object
-- a large data set, for example -- there may be a noticeable performance
penalty.

If you face these issues with the cache key, you can work around them by
extracting out the important parts of the objects, and/or by converting them
to normal R objects before returning them. Your expression could even
serialize and hash that information in an efficient way and return a string,
which will in turn be hashed (very quickly) by the
\code{\link[digest]{digest}} function.

\code{cacheResetEventExpr} is an expression that uses reactive values like
\code{input$click} and/or reactive expressions like \code{data()}. The
\code{cacheResetEventExpr} parameter works similarly to the \code{eventExpr}
parameter of \code{\link{observeEvent}}: whenever the upstream reactive
dependencies are invalidated, they cause this expression to re-execute, and
the cache is reset -- the contents are erased. The cache should be reset when
something changes so that a plot made with the same cache key as before would
have a different result. This may happen when, for example, the underlying
data changes. If the plot is based on a data source that changes over time,
the plot at time 1 may differ from the plot at time 2, even if both plots use
the same cache key.

Another way to use \code{cacheResetEventExpr} is to have it clear the cache
at a fixed time interval using \code{\link{invalidateLater}}. For example,
you might want to have clear the cache once per hour, or once per day.

Although both \code{cacheKeyExpr} and \code{cacheResetEventExpr} are reactive
-- they re-execute when their upstream reactive dependencies are invalidated
-- they differ in how they use the return value. For \code{cacheKeyExpr}, the
returned value is used (as a key). In contrast, for
\code{cacheResetEventExpr}, the return value is ignored; the invalidation of
the expression is used only to signal that the cache should be reset.
}
\section{Cache scoping}{


  There are a number of different ways you may want to scope the cache. For
  example, you may want each user session to have their own plot cache, or
  you may want each run of the application to have a cache (shared among
  possibly multiple simultaneous user sessions), or you may want to have a
  cache that persists even after the application is shut down and started
  again.

  To control the scope of the cache, use the \code{scope} parameter. There
  are two ways of having Shiny automatically create and clean up the disk
  cache.

\describe{
  \item{1}{To scope the cache to one session, use \code{scope="session"}.
    When a new user session starts -- in other words, when a web browser
    visits the Shiny application -- a new cache will be created on disk
    for that session. When the session ends, the cache will be deleted.
    The cache will not be shared across multiple sessions.}
  \item{2}{To scope the cache to one run of a Shiny application (shared
    among possibly multiple user sessions), use \code{scope="app"}. This
    is the default. The cache will be shared across multiple sessions, so
    there is potentially a large performance benefit if there are many users
    of the application. If plots cannot be safely shared across users, this
    should not be used.}
 }

  In some cases, you may want to manually specify the cache directory. This
  can be useful if you want the cache to persist across multiple runs of an
  application, or even across multiple R processes.

\describe{
  \item{3}{To have the cache persist across multiple runs of an R process,
    use \code{scope=file.path(dirname(tempdir()), "plot1_cache")}.
    This will create a subdirectory in your system temp directory named
    \code{plot1_cache} (where \code{plot1_cache} is replaced with a unique
    name of your choosing). When the R process exits, it will automatically
    be removed.}
  \item{4}{To have the cache persist even across multiple R processes, you
    can set \code{cacheDir} to a location outside of the temp directory.
    For example, it could be a subdirectory of the application, as in
    \code{scope="plot1_cache"}}.
}

  Please note that if you specify a directory, that directory should only be
  used to plot cache files. If it contains any other files or directories,
  they could be removed when the cache is invalidated. Additionally, the
  directory will not automatically be cleaned up or removed when the Shiny
  application exits.
}

